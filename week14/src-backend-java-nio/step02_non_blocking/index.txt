1. 네트워크 프로그램 구현 방식
    - 블로킹 소켓 기반의 구현
        Q. 활용 API?
            -> 소켓과 인풋/아웃풋 스트림

2. 서버 - 클라이언트 간 데이터 송/수신 방식
    - 스트림
    - 버퍼
        Q. 버퍼란?
            -> 임시 메모리를 활용하여 스트림보다 더 빠르고 재사용 가능한 클래스

        Q. 버퍼를 활용하여 송수신을 보다 빠르게 처리하는 방법?
            -> 버퍼가 적용된 BufferedReader

3. 다중 사용자 접속 처리하기
    Q. 처음에 구현한 블로킹 방식의 네트워크 프로그램의 특징?
        -> Java OIO(Old IO, Java 1.4 이전) API인 ServerSocket과 Socket을 활용,
            블로킹으로 동작, 1:1 연결 밖에 지원하지 않음

    Q. 하나의 서버로 둘 이상의 클라이언트를 받는 방법?
        -> 총 2가지
            1. 멀티 프로세싱
            2. 멀티 스레딩
                2-1. 요청당 스레딩 모델
                    Q. 요청당 스레드 모델의 장단점?

                2-2. 스레드 풀링 모델
                    Q. 스레드 풀링 모델의 장단점?
                    Q. 스레드 풀에 생성될 적정 스레드 수 계산 방법?

                Q. 스레드 풀링 모델의 단점 개선하기 위한 방법?
                    -> 스레드가 IO 연산을 수행하는 동안에도 쉬지 않고, 다른 작업을 처리할 수 있는
                    논블로킹 메커니즘을 활용

                    논블로킹에서는 스레드가 IO 작업을 수행하는 메서드를 호출하는 즉시 반환되며,
                    작업이 아직 완료되지 않아도 스레드가 차단되지 않음

                    이를 통해 하나의 스레드만 가지고도 둘 이상의 다중 접속 사용자를 처리할 수 있음
                    (OS 레벨의 메커니즘에서는 IO 멀티 플렉싱, 입출력 다중화라고 함)
        정리하면, 하나의 서버로 둘 이상의 사용자 접속을 받는 방법은 두 가지가 아닌 총 세 가지
            ->  1. 멀티 프로세싱
                2. 멀티 스레딩
                3. 멀티 플렉싱(Java 1.4~에서 등장한 Java NIO, New, Non-blocking)
4. 논블로킹 기반의 네트워크 프로그램을 구현하기 위해 필요한 몇 가지 API
    Q. 채널이란?
        -> 스트림 기반의 블로킹 IO를 사용했던 초기 Java OIO에서는 대량의 데이터를 효율적으로 처리하거나
        고성능 네트워크 서버를 구축하기에는 한계가 있었기 때문에 등장한 API
        Selector와 결합할 경우에는 논블로킹 메커니즘을 구현할 수 있음

    Q. 채널의 특징?
        -> 채널은 Buffer를 활용하여 데이터를 블록 단위로 처리, 스트림에 비해 속도가 빠르고 효율적임
        단방향으로 통신하는 스트림과는 다르게(InputStream, OutputStream)
        채널은 양방향으로 통신

    Q. 셀렉터란?
        -> OS의 IO 멀티플렉싱 메커니즘을 지원하는 API,
        여러 개의 Channel 들을 단일 스레드를 통해 감시하여(select()) OIO에 비해 서버의 확장성 개선
        Selector는 하나의 스레드가 여러 개의 Non-blocking 채널들을 감시할 수 있도록 도와주는 멀티 플렉싱 툴
        이벤트 기반으로 IO를 처리함
            이 맥락에서 이벤트의 예시는?
            ex. 클라이언트 - 서버 간의 연결, 데이터 송/수신, 과정에서 발생한 에러 등